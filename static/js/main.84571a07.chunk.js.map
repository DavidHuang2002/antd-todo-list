{"version":3,"sources":["Todo.js","index.js"],"names":["Title","Typography","Paragraph","Text","findTodoByID","todos","id","i","length","console","error","InputTodo","addTodo","useState","inputVal","setInputVal","placeholder","value","onChange","e","target","onPressEnter","TodoItem","todo","onRemove","onDateChange","Item","actions","date","_","CloseCircleOutlined","onClick","content","Todo","props","undo","state","nextId","history","prev","current","concat","newHistory","setState","log","redo","addInput","todoContent","newTodos","editTodos","removeItem","todoID","itemIdx","slice","splice","handleDateChange","todoId","todoIdx","newTodoItem","Object","assign","this","window","addEventListener","event","ctrlKey","shiftKey","key","toLowerCase","className","keyboard","dataSource","locale","emptyText","renderItem","item","Component","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.84571a07.chunk.js","sourcesContent":["import React from \"react\";\nimport { Component, useState} from \"react\";\nimport { Input, List, DatePicker} from \"antd\";\nimport {CloseCircleOutlined} from '@ant-design/icons';\n\nimport { Typography } from 'antd';\nconst { Title, Paragraph, Text } = Typography;\n\n// PLAN\n// add an event listener- cmd-z / cmd-shift-z to undo/redo changes\n// keep track of the previous state in history\n  // history\n    // prev: array of old states\n      // question-should I track the nextId? maybe not, that will complicate the situation\n    // current: normally null, but when undoing, track the pos in history\n    \n\n  // each new todos, add the old todos&nextId to history\n    // helper func\n    // if current is not null\n      // truncate next parts of history(can't redo now)\n      // set to current null\n    \n  // undo\n    // check if there are history to revert to, else do nothing\n      // prev non empty\n      // current not set to 0\n    // set current to place to revert to\n      // if !current, set current to prev.len \n      // else current = current-1\n    // add the state now to history(so we can redo)\n    // set todos&nextId to prev[current] - helper func\n\n  // redo\n    // check if there are states to redo to\n      // current not null\n    // set current to place to redo to\n      // current = current + 1\n      // if current == len - 1, current=null\n    // set todos&nextId to prev[current]\n\nclass Todo extends Component {\n\tconstructor(props) {\n\t\tsuper(props);\n\n\t\tthis.state = {\n      // note: history only tracks of past states, the current state is not in it\n      history: {\n        prev: [],\n        current: null,\n      },\n\t\t\ttodos: [],\n      nextId: 0\n\t\t}\n\t}\n\n  // --- undo/redo ---\n  // helper func for changing todos\n  editTodos(newTodos){\n    const {todos, nextId, history} = this.state;\n    let {prev, current} = history;\n    // if the current is not null, truncate prev, set current to null\n    // so you can't redo after editing\n\n    //TODO: something is off...\n    if(current||(current===0)){\n      // do not include the current state\n      // since it will be added later anyway\n      prev = prev.slice(0, current);\n      current = null;\n    }\n\n    // add current todos to history\n    const newPrev = prev.concat({\n      todos: todos,\n      nextId: nextId\n    });\n    const newHistory = {\n      prev: newPrev,\n      current: current\n    }\n    \n    this.setState({history: newHistory});\n    \n    // change state to newTodos\n    this.setState({todos: newTodos});\n  }\n\n  undo = () => {\n    const {todos, nextId} = this.state;\n    let {prev, current} = this.state.history;\n    \n    // check if there are history to revert to\n      // prev non-empty\n      // not in earliest history(current=0)\n    if ((!prev)||(current===0)){\n      console.log('Undo failed: no history revert back to');\n      return;\n    }\n\n    // set current to place to revert to\n    if (!current) {\n      // if this is the first undo \n      // add the state now to history(so we can redo)\n      current = prev.length - 1;\n\n      prev = prev.concat({\n        todos: todos,\n        nextId: nextId\n      });\n    } else {\n      current = current - 1;\n    }\n    const newHistory = {\n      prev: prev,\n      current: current\n    }\n    this.setState({history: newHistory});\n\n    // set todos&nextId to prev[current]\n    this.setState(prev[current]);\n  }\n\n  redo = ()=>{\n    let {current, prev} = this.state.history;\n\n    // check if there are states to redo to\n    // if current state is at the end of history list\n    // there is no future states to redo to, set current to null\n    if (current===(prev.length-1)){\n      current = null;\n    }\n    if (current===null) {\n      console.log('redo fails: no state to redo to');\n      return;\n    }\n\n    // set current to place to redo to\n    current = current + 1;\n    \n    this.setState({history: {\n      prev: prev,\n      current: current\n    }})\n\n    // set todos&nextId to prev[current]\n    this.setState(prev[current]);\n  }\n\n  // event listening for ctrl+z / ctrl+shift+z\n  componentDidMount() {\n    // event for undo&redo\n    window.addEventListener('keydown', (event) => {\n      if (event.ctrlKey\n        &&event.shiftKey\n        &&event.key.toLowerCase() === 'z') {\n        this.redo();\n      } else if (event.ctrlKey\n        &&event.key.toLowerCase() === 'z') {\n        this.undo();\n      } \n    });\n  }\n  \n\n  addInput = (todoContent)=>{\n    const {todos, nextId} = this.state;\n\n    const newTodos = todos.concat(\n      {\n        // unique id to every todo item\n        id: nextId,\n        content: todoContent,\n        date: null,\n      }\n    );\n    \n    this.editTodos(newTodos);\n    this.setState({\n      nextId: nextId+1,\n    });\n  }\n\n  removeItem = todoID=>{\n    const {todos} = this.state;\n\n    const itemIdx = findTodoByID(todos, todoID);\n    const newTodos = todos.slice();\n    newTodos.splice(itemIdx, 1);\n\n    this.editTodos(newTodos);\n  }\n\n  handleDateChange = (date, todoId)=>{\n    const{todos} = this.state;\n    const todoIdx = findTodoByID(todos, todoId);\n   \n\n    // making copy instead of modifying the object to allow functionality like \n    // undo changes in future\n    // not changing the id because the old item is immediately replaced by the new\n    // one so there are no need to worry about duplicate ids\n    const newTodoItem = Object.assign({}, todos[todoIdx]);\n    newTodoItem.date = date;\n\n    const newTodos = todos.slice();\n    newTodos[todoIdx] = newTodoItem;\n    this.editTodos(newTodos);\n  }\n\n\trender() {\n\t\treturn (\n\t\t\t<div className=\"todoContainer\">\n        <Typography>\n          <Title>ToDo List</Title>\n          \n          <Paragraph> \n            Press <Text keyboard>Enter</Text> to input a list item\n          </Paragraph>\n\n          <Paragraph> \n            Use <Text keyboard>Ctrl+Z</Text> to undo, \n            <Text keyboard>Ctrl+Shift+Z</Text> to redo\n          </Paragraph>\n        </Typography>\n\n        <InputTodo\n          addTodo={this.addInput}\n        />\n\n        <List \n          dataSource={this.state.todos}\n          locale={{emptyText: \"Nothing todo yet\"}}\n          renderItem={item=>(\n            <TodoItem\n              todo={item}\n              onRemove={this.removeItem}\n              onDateChange={this.handleDateChange}\n            />\n          )}\n        />\n        \n\t\t\t</div>\n\t\t);\n\t}\n}\n\n// helper function, return the index of a todo with certain id\n// if not find, throw an error\nfunction findTodoByID(todos, id ){\n  for(let i=0; i<todos.length; i++){\n    if(todos[i].id === id){\n      return i;\n    }\n  }\n  throw console.error(\"no todo item with that id!\");\n}\n\n\n// controlled element for input section that adds todo\n// simply using e.target.value = \"new\"; to clear Input doesnt work for this version of antd\n// had to create a hook to manage the value of Input\nfunction InputTodo({addTodo}){\n  const [inputVal, setInputVal] = useState(\"\");\n\n  const handleChange = e=>{\n    setInputVal(e.target.value);\n  }\n\n  const handlePressEnter = e=>{\n    addTodo(e.target.value);\n    // clear the input\n    setInputVal(\"\");\n  }\n\n  return (\n    <Input\n      placeholder=\"What needs to be done?\"\n      value={inputVal}\n      onChange={handleChange}\n      onPressEnter={handlePressEnter}\n    />\n  );\n}\n\n\nfunction TodoItem({todo, onRemove, onDateChange}){\n  return (\n    <List.Item \n      actions={[\n        <DatePicker \n          onChange={(date, _)=>onDateChange(date, todo.id)}\n          value={todo.date}\n        />,\n        <CloseCircleOutlined\n          onClick={()=>{onRemove(todo.id)}}\n        />,\n      ]}\n    >\n      {todo.content}\n    </List.Item>\n  );\n}\n\nexport default Todo;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport Todo from './Todo';\nimport './index.css';\nimport \"antd/dist/antd.css\";\n\nReactDOM.render(\n    <Todo />,\n    document.getElementById('root')\n);"],"sourceRoot":""}